// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TursomMsg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_TursomMsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_TursomMsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>

#if PROTOBUF_VERSION < 3017000
                                                                                                                        #error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017000 < PROTOBUF_MIN_PROTOC_VERSION
                                                                                                                        #error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

#define PROTOBUF_INTERNAL_EXPORT_TursomMsg_2eproto
PROTOBUF_NAMESPACE_OPEN
        namespace internal {
            class AnyMetadata;
        }  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_TursomMsg_2eproto {
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
    static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
    static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_TursomMsg_2eproto;
namespace cn {
    namespace tursom {
        namespace im {
            namespace protobuf {
                class ChatMsg;

                struct ChatMsgDefaultTypeInternal;
                extern ChatMsgDefaultTypeInternal _ChatMsg_default_instance_;

                class ImMsg;

                struct ImMsgDefaultTypeInternal;
                extern ImMsgDefaultTypeInternal _ImMsg_default_instance_;

                class LoginRequest;

                struct LoginRequestDefaultTypeInternal;
                extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;

                class LoginResult;

                struct LoginResultDefaultTypeInternal;
                extern LoginResultDefaultTypeInternal _LoginResult_default_instance_;

                class MsgContent;

                struct MsgContentDefaultTypeInternal;
                extern MsgContentDefaultTypeInternal _MsgContent_default_instance_;

                class SendMsgRequest;

                struct SendMsgRequestDefaultTypeInternal;
                extern SendMsgRequestDefaultTypeInternal _SendMsgRequest_default_instance_;

                class SendMsgResponse;

                struct SendMsgResponseDefaultTypeInternal;
                extern SendMsgResponseDefaultTypeInternal _SendMsgResponse_default_instance_;
            }  // namespace protobuf
        }  // namespace im
    }  // namespace tursom
}  // namespace cn
PROTOBUF_NAMESPACE_OPEN
        template<>
        ::cn::tursom::im::protobuf::ChatMsg *Arena::CreateMaybeMessage<::cn::tursom::im::protobuf::ChatMsg>(Arena *);

        template<>
        ::cn::tursom::im::protobuf::ImMsg *Arena::CreateMaybeMessage<::cn::tursom::im::protobuf::ImMsg>(Arena *);

        template<>
        ::cn::tursom::im::protobuf::LoginRequest *
        Arena::CreateMaybeMessage<::cn::tursom::im::protobuf::LoginRequest>(Arena *);

        template<>
        ::cn::tursom::im::protobuf::LoginResult *
        Arena::CreateMaybeMessage<::cn::tursom::im::protobuf::LoginResult>(Arena *);

        template<>
        ::cn::tursom::im::protobuf::MsgContent *
        Arena::CreateMaybeMessage<::cn::tursom::im::protobuf::MsgContent>(Arena *);

        template<>
        ::cn::tursom::im::protobuf::SendMsgRequest *
        Arena::CreateMaybeMessage<::cn::tursom::im::protobuf::SendMsgRequest>(Arena *);

        template<>
        ::cn::tursom::im::protobuf::SendMsgResponse *
        Arena::CreateMaybeMessage<::cn::tursom::im::protobuf::SendMsgResponse>(Arena *);
PROTOBUF_NAMESPACE_CLOSE
namespace cn {
    namespace tursom {
        namespace im {
            namespace protobuf {

                enum FailType : int {
                    UNKNOWN = 0,
                    IN_BLACKLIST = 1,
                    TARGET_NOT_LOGIN = 2,
                    MSG_SAVE_FAILURE = 3,
                    TARGET_IS_EMPTY = 4,
                    GROUP_NOT_EXIST = 5,
                    GROUP_MUTED = 6,
                    GROUP_USER_MUTED = 7,
                    USER_NOT_IN_GROUP = 8,
                    FailType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
                    FailType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
                };

                bool FailType_IsValid(int value);

                constexpr FailType FailType_MIN = UNKNOWN;
                constexpr FailType FailType_MAX = USER_NOT_IN_GROUP;
                constexpr int FailType_ARRAYSIZE = FailType_MAX + 1;

                const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor *FailType_descriptor();

                template<typename T>
                inline const std::string &FailType_Name(T enum_t_value) {
                    static_assert(::std::is_same<T, FailType>::value ||
                                  ::std::is_integral<T>::value,
                                  "Incorrect type passed to function FailType_Name.");
                    return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
                            FailType_descriptor(), enum_t_value);
                }

                inline bool FailType_Parse(
                        ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FailType *value) {
                    return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FailType>(
                            FailType_descriptor(), name, value);
                }
// ===================================================================

                class ImMsg final :
                        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.tursom.im.protobuf.ImMsg) */ {
                public:
                    inline ImMsg() : ImMsg(nullptr) {}

                    ~ImMsg() override;

                    explicit constexpr ImMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

                    ImMsg(const ImMsg &from);

                    ImMsg(ImMsg &&from) noexcept
                            : ImMsg() {
                        *this = ::std::move(from);
                    }

                    inline ImMsg &operator=(const ImMsg &from) {
                        CopyFrom(from);
                        return *this;
                    }

                    inline ImMsg &operator=(ImMsg &&from) noexcept {
                        if (this == &from) return *this;
                        if (GetOwningArena() == from.GetOwningArena()) {
                            InternalSwap(&from);
                        } else {
                            CopyFrom(from);
                        }
                        return *this;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                        return GetDescriptor();
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                        return default_instance().GetMetadata().descriptor;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                        return default_instance().GetMetadata().reflection;
                    }

                    static const ImMsg &default_instance() {
                        return *internal_default_instance();
                    }

                    enum ContentCase {
                        kLoginRequest = 2,
                        kLoginResult = 3,
                        kChatMsg = 4,
                        kSendMsgRequest = 5,
                        kSendMsgResponse = 6,
                        kHeartBeat = 8,
                        CONTENT_NOT_SET = 0,
                    };

                    static inline const ImMsg *internal_default_instance() {
                        return reinterpret_cast<const ImMsg *>(
                                &_ImMsg_default_instance_);
                    }

                    static constexpr int kIndexInFileMessages =
                            0;

                    friend void swap(ImMsg &a, ImMsg &b) {
                        a.Swap(&b);
                    }

                    inline void Swap(ImMsg *other) {
                        if (other == this) return;
                        if (GetOwningArena() == other->GetOwningArena()) {
                            InternalSwap(other);
                        } else {
                            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
                        }
                    }

                    void UnsafeArenaSwap(ImMsg *other) {
                        if (other == this) return;
                        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
                        InternalSwap(other);
                    }

                    // implements Message ----------------------------------------------

                    inline ImMsg *New() const final {
                        return new ImMsg();
                    }

                    ImMsg *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                        return CreateMaybeMessage<ImMsg>(arena);
                    }

                    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void CopyFrom(const ImMsg &from);

                    void MergeFrom(const ImMsg &from);

                    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

                    bool IsInitialized() const final;

                    size_t ByteSizeLong() const final;

                    const char *
                    _InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

                    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
                            ::PROTOBUF_NAMESPACE_ID::uint8 *target,
                            ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

                    int GetCachedSize() const final { return _cached_size_.Get(); }

                private:
                    void SharedCtor();

                    void SharedDtor();

                    void SetCachedSize(int size) const final;

                    void InternalSwap(ImMsg *other);

                    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

                    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                        return "cn.tursom.im.protobuf.ImMsg";
                    }

                protected:
                    explicit ImMsg(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                private:
                    static void ArenaDtor(void *object);

                    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                public:

                    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

                    // nested types ----------------------------------------------------

                    // accessors -------------------------------------------------------

                    enum : int {
                        kMsgIdFieldNumber = 1,
                        kSelfMsgFieldNumber = 7,
                        kLoginRequestFieldNumber = 2,
                        kLoginResultFieldNumber = 3,
                        kChatMsgFieldNumber = 4,
                        kSendMsgRequestFieldNumber = 5,
                        kSendMsgResponseFieldNumber = 6,
                        kHeartBeatFieldNumber = 8,
                    };

                    // string msgId = 1;
                    void clear_msgid();

                    const std::string &msgid() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_msgid(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_msgid();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_msgid();

                    void set_allocated_msgid(std::string *msgid);

                private:
                    const std::string &_internal_msgid() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_msgid(const std::string &value);

                    std::string *_internal_mutable_msgid();

                public:

                    // bool selfMsg = 7;
                    void clear_selfmsg();

                    bool selfmsg() const;

                    void set_selfmsg(bool value);

                private:
                    bool _internal_selfmsg() const;

                    void _internal_set_selfmsg(bool value);

                public:

                    // .cn.tursom.im.protobuf.LoginRequest loginRequest = 2;
                    bool has_loginrequest() const;

                private:
                    bool _internal_has_loginrequest() const;

                public:
                    void clear_loginrequest();

                    const ::cn::tursom::im::protobuf::LoginRequest &loginrequest() const;

                    PROTOBUF_FUTURE_MUST_USE_RESULT ::cn::tursom::im::protobuf::LoginRequest *release_loginrequest();

                    ::cn::tursom::im::protobuf::LoginRequest *mutable_loginrequest();

                    void set_allocated_loginrequest(::cn::tursom::im::protobuf::LoginRequest *loginrequest);

                private:
                    const ::cn::tursom::im::protobuf::LoginRequest &_internal_loginrequest() const;

                    ::cn::tursom::im::protobuf::LoginRequest *_internal_mutable_loginrequest();

                public:
                    void unsafe_arena_set_allocated_loginrequest(
                            ::cn::tursom::im::protobuf::LoginRequest *loginrequest);

                    ::cn::tursom::im::protobuf::LoginRequest *unsafe_arena_release_loginrequest();

                    // .cn.tursom.im.protobuf.LoginResult loginResult = 3;
                    bool has_loginresult() const;

                private:
                    bool _internal_has_loginresult() const;

                public:
                    void clear_loginresult();

                    const ::cn::tursom::im::protobuf::LoginResult &loginresult() const;

                    PROTOBUF_FUTURE_MUST_USE_RESULT ::cn::tursom::im::protobuf::LoginResult *release_loginresult();

                    ::cn::tursom::im::protobuf::LoginResult *mutable_loginresult();

                    void set_allocated_loginresult(::cn::tursom::im::protobuf::LoginResult *loginresult);

                private:
                    const ::cn::tursom::im::protobuf::LoginResult &_internal_loginresult() const;

                    ::cn::tursom::im::protobuf::LoginResult *_internal_mutable_loginresult();

                public:
                    void unsafe_arena_set_allocated_loginresult(
                            ::cn::tursom::im::protobuf::LoginResult *loginresult);

                    ::cn::tursom::im::protobuf::LoginResult *unsafe_arena_release_loginresult();

                    // .cn.tursom.im.protobuf.ChatMsg chatMsg = 4;
                    bool has_chatmsg() const;

                private:
                    bool _internal_has_chatmsg() const;

                public:
                    void clear_chatmsg();

                    const ::cn::tursom::im::protobuf::ChatMsg &chatmsg() const;

                    PROTOBUF_FUTURE_MUST_USE_RESULT ::cn::tursom::im::protobuf::ChatMsg *release_chatmsg();

                    ::cn::tursom::im::protobuf::ChatMsg *mutable_chatmsg();

                    void set_allocated_chatmsg(::cn::tursom::im::protobuf::ChatMsg *chatmsg);

                private:
                    const ::cn::tursom::im::protobuf::ChatMsg &_internal_chatmsg() const;

                    ::cn::tursom::im::protobuf::ChatMsg *_internal_mutable_chatmsg();

                public:
                    void unsafe_arena_set_allocated_chatmsg(
                            ::cn::tursom::im::protobuf::ChatMsg *chatmsg);

                    ::cn::tursom::im::protobuf::ChatMsg *unsafe_arena_release_chatmsg();

                    // .cn.tursom.im.protobuf.SendMsgRequest sendMsgRequest = 5;
                    bool has_sendmsgrequest() const;

                private:
                    bool _internal_has_sendmsgrequest() const;

                public:
                    void clear_sendmsgrequest();

                    const ::cn::tursom::im::protobuf::SendMsgRequest &sendmsgrequest() const;

                    PROTOBUF_FUTURE_MUST_USE_RESULT ::cn::tursom::im::protobuf::SendMsgRequest *
                    release_sendmsgrequest();

                    ::cn::tursom::im::protobuf::SendMsgRequest *mutable_sendmsgrequest();

                    void set_allocated_sendmsgrequest(::cn::tursom::im::protobuf::SendMsgRequest *sendmsgrequest);

                private:
                    const ::cn::tursom::im::protobuf::SendMsgRequest &_internal_sendmsgrequest() const;

                    ::cn::tursom::im::protobuf::SendMsgRequest *_internal_mutable_sendmsgrequest();

                public:
                    void unsafe_arena_set_allocated_sendmsgrequest(
                            ::cn::tursom::im::protobuf::SendMsgRequest *sendmsgrequest);

                    ::cn::tursom::im::protobuf::SendMsgRequest *unsafe_arena_release_sendmsgrequest();

                    // .cn.tursom.im.protobuf.SendMsgResponse sendMsgResponse = 6;
                    bool has_sendmsgresponse() const;

                private:
                    bool _internal_has_sendmsgresponse() const;

                public:
                    void clear_sendmsgresponse();

                    const ::cn::tursom::im::protobuf::SendMsgResponse &sendmsgresponse() const;

                    PROTOBUF_FUTURE_MUST_USE_RESULT ::cn::tursom::im::protobuf::SendMsgResponse *
                    release_sendmsgresponse();

                    ::cn::tursom::im::protobuf::SendMsgResponse *mutable_sendmsgresponse();

                    void set_allocated_sendmsgresponse(::cn::tursom::im::protobuf::SendMsgResponse *sendmsgresponse);

                private:
                    const ::cn::tursom::im::protobuf::SendMsgResponse &_internal_sendmsgresponse() const;

                    ::cn::tursom::im::protobuf::SendMsgResponse *_internal_mutable_sendmsgresponse();

                public:
                    void unsafe_arena_set_allocated_sendmsgresponse(
                            ::cn::tursom::im::protobuf::SendMsgResponse *sendmsgresponse);

                    ::cn::tursom::im::protobuf::SendMsgResponse *unsafe_arena_release_sendmsgresponse();

                    // string heartBeat = 8;
                    bool has_heartbeat() const;

                private:
                    bool _internal_has_heartbeat() const;

                public:
                    void clear_heartbeat();

                    const std::string &heartbeat() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_heartbeat(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_heartbeat();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_heartbeat();

                    void set_allocated_heartbeat(std::string *heartbeat);

                private:
                    const std::string &_internal_heartbeat() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_heartbeat(const std::string &value);

                    std::string *_internal_mutable_heartbeat();

                public:

                    void clear_content();

                    ContentCase content_case() const;
                    // @@protoc_insertion_point(class_scope:cn.tursom.im.protobuf.ImMsg)
                private:
                    class _Internal;

                    void set_has_loginrequest();

                    void set_has_loginresult();

                    void set_has_chatmsg();

                    void set_has_sendmsgrequest();

                    void set_has_sendmsgresponse();

                    void set_has_heartbeat();

                    inline bool has_content() const;

                    inline void clear_has_content();

                    template<typename T> friend
                    class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;

                    typedef void InternalArenaConstructable_;
                    typedef void DestructorSkippable_;
                    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msgid_;
                    bool selfmsg_;

                    union ContentUnion {
                        constexpr ContentUnion() : _constinit_{} {}

                        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
                        ::cn::tursom::im::protobuf::LoginRequest *loginrequest_;
                        ::cn::tursom::im::protobuf::LoginResult *loginresult_;
                        ::cn::tursom::im::protobuf::ChatMsg *chatmsg_;
                        ::cn::tursom::im::protobuf::SendMsgRequest *sendmsgrequest_;
                        ::cn::tursom::im::protobuf::SendMsgResponse *sendmsgresponse_;
                        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr heartbeat_;
                    } content_;

                    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
                    ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

                    friend struct ::TableStruct_TursomMsg_2eproto;
                };
// -------------------------------------------------------------------

                class LoginRequest final :
                        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.tursom.im.protobuf.LoginRequest) */ {
                public:
                    inline LoginRequest() : LoginRequest(nullptr) {}

                    ~LoginRequest() override;

                    explicit constexpr LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

                    LoginRequest(const LoginRequest &from);

                    LoginRequest(LoginRequest &&from) noexcept
                            : LoginRequest() {
                        *this = ::std::move(from);
                    }

                    inline LoginRequest &operator=(const LoginRequest &from) {
                        CopyFrom(from);
                        return *this;
                    }

                    inline LoginRequest &operator=(LoginRequest &&from) noexcept {
                        if (this == &from) return *this;
                        if (GetOwningArena() == from.GetOwningArena()) {
                            InternalSwap(&from);
                        } else {
                            CopyFrom(from);
                        }
                        return *this;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                        return GetDescriptor();
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                        return default_instance().GetMetadata().descriptor;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                        return default_instance().GetMetadata().reflection;
                    }

                    static const LoginRequest &default_instance() {
                        return *internal_default_instance();
                    }

                    static inline const LoginRequest *internal_default_instance() {
                        return reinterpret_cast<const LoginRequest *>(
                                &_LoginRequest_default_instance_);
                    }

                    static constexpr int kIndexInFileMessages =
                            1;

                    friend void swap(LoginRequest &a, LoginRequest &b) {
                        a.Swap(&b);
                    }

                    inline void Swap(LoginRequest *other) {
                        if (other == this) return;
                        if (GetOwningArena() == other->GetOwningArena()) {
                            InternalSwap(other);
                        } else {
                            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
                        }
                    }

                    void UnsafeArenaSwap(LoginRequest *other) {
                        if (other == this) return;
                        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
                        InternalSwap(other);
                    }

                    // implements Message ----------------------------------------------

                    inline LoginRequest *New() const final {
                        return new LoginRequest();
                    }

                    LoginRequest *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                        return CreateMaybeMessage<LoginRequest>(arena);
                    }

                    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void CopyFrom(const LoginRequest &from);

                    void MergeFrom(const LoginRequest &from);

                    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

                    bool IsInitialized() const final;

                    size_t ByteSizeLong() const final;

                    const char *
                    _InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

                    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
                            ::PROTOBUF_NAMESPACE_ID::uint8 *target,
                            ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

                    int GetCachedSize() const final { return _cached_size_.Get(); }

                private:
                    void SharedCtor();

                    void SharedDtor();

                    void SetCachedSize(int size) const final;

                    void InternalSwap(LoginRequest *other);

                    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

                    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                        return "cn.tursom.im.protobuf.LoginRequest";
                    }

                protected:
                    explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                private:
                    static void ArenaDtor(void *object);

                    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                public:

                    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

                    // nested types ----------------------------------------------------

                    // accessors -------------------------------------------------------

                    enum : int {
                        kTokenFieldNumber = 1,
                    };

                    // string token = 1;
                    void clear_token();

                    const std::string &token() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_token(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_token();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_token();

                    void set_allocated_token(std::string *token);

                private:
                    const std::string &_internal_token() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string &value);

                    std::string *_internal_mutable_token();

                public:

                    // @@protoc_insertion_point(class_scope:cn.tursom.im.protobuf.LoginRequest)
                private:
                    class _Internal;

                    template<typename T> friend
                    class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;

                    typedef void InternalArenaConstructable_;
                    typedef void DestructorSkippable_;
                    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
                    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
                    friend struct ::TableStruct_TursomMsg_2eproto;
                };
// -------------------------------------------------------------------

                class LoginResult final :
                        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.tursom.im.protobuf.LoginResult) */ {
                public:
                    inline LoginResult() : LoginResult(nullptr) {}

                    ~LoginResult() override;

                    explicit constexpr LoginResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

                    LoginResult(const LoginResult &from);

                    LoginResult(LoginResult &&from) noexcept
                            : LoginResult() {
                        *this = ::std::move(from);
                    }

                    inline LoginResult &operator=(const LoginResult &from) {
                        CopyFrom(from);
                        return *this;
                    }

                    inline LoginResult &operator=(LoginResult &&from) noexcept {
                        if (this == &from) return *this;
                        if (GetOwningArena() == from.GetOwningArena()) {
                            InternalSwap(&from);
                        } else {
                            CopyFrom(from);
                        }
                        return *this;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                        return GetDescriptor();
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                        return default_instance().GetMetadata().descriptor;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                        return default_instance().GetMetadata().reflection;
                    }

                    static const LoginResult &default_instance() {
                        return *internal_default_instance();
                    }

                    static inline const LoginResult *internal_default_instance() {
                        return reinterpret_cast<const LoginResult *>(
                                &_LoginResult_default_instance_);
                    }

                    static constexpr int kIndexInFileMessages =
                            2;

                    friend void swap(LoginResult &a, LoginResult &b) {
                        a.Swap(&b);
                    }

                    inline void Swap(LoginResult *other) {
                        if (other == this) return;
                        if (GetOwningArena() == other->GetOwningArena()) {
                            InternalSwap(other);
                        } else {
                            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
                        }
                    }

                    void UnsafeArenaSwap(LoginResult *other) {
                        if (other == this) return;
                        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
                        InternalSwap(other);
                    }

                    // implements Message ----------------------------------------------

                    inline LoginResult *New() const final {
                        return new LoginResult();
                    }

                    LoginResult *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                        return CreateMaybeMessage<LoginResult>(arena);
                    }

                    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void CopyFrom(const LoginResult &from);

                    void MergeFrom(const LoginResult &from);

                    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

                    bool IsInitialized() const final;

                    size_t ByteSizeLong() const final;

                    const char *
                    _InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

                    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
                            ::PROTOBUF_NAMESPACE_ID::uint8 *target,
                            ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

                    int GetCachedSize() const final { return _cached_size_.Get(); }

                private:
                    void SharedCtor();

                    void SharedDtor();

                    void SetCachedSize(int size) const final;

                    void InternalSwap(LoginResult *other);

                    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

                    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                        return "cn.tursom.im.protobuf.LoginResult";
                    }

                protected:
                    explicit LoginResult(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                private:
                    static void ArenaDtor(void *object);

                    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                public:

                    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

                    // nested types ----------------------------------------------------

                    // accessors -------------------------------------------------------

                    enum : int {
                        kImUserIdFieldNumber = 2,
                        kSuccessFieldNumber = 1,
                    };

                    // string imUserId = 2;
                    void clear_imuserid();

                    const std::string &imuserid() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_imuserid(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_imuserid();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_imuserid();

                    void set_allocated_imuserid(std::string *imuserid);

                private:
                    const std::string &_internal_imuserid() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_imuserid(const std::string &value);

                    std::string *_internal_mutable_imuserid();

                public:

                    // bool success = 1;
                    void clear_success();

                    bool success() const;

                    void set_success(bool value);

                private:
                    bool _internal_success() const;

                    void _internal_set_success(bool value);

                public:

                    // @@protoc_insertion_point(class_scope:cn.tursom.im.protobuf.LoginResult)
                private:
                    class _Internal;

                    template<typename T> friend
                    class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;

                    typedef void InternalArenaConstructable_;
                    typedef void DestructorSkippable_;
                    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imuserid_;
                    bool success_;
                    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
                    friend struct ::TableStruct_TursomMsg_2eproto;
                };
// -------------------------------------------------------------------

                class MsgContent final :
                        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.tursom.im.protobuf.MsgContent) */ {
                public:
                    inline MsgContent() : MsgContent(nullptr) {}

                    ~MsgContent() override;

                    explicit constexpr MsgContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

                    MsgContent(const MsgContent &from);

                    MsgContent(MsgContent &&from) noexcept
                            : MsgContent() {
                        *this = ::std::move(from);
                    }

                    inline MsgContent &operator=(const MsgContent &from) {
                        CopyFrom(from);
                        return *this;
                    }

                    inline MsgContent &operator=(MsgContent &&from) noexcept {
                        if (this == &from) return *this;
                        if (GetOwningArena() == from.GetOwningArena()) {
                            InternalSwap(&from);
                        } else {
                            CopyFrom(from);
                        }
                        return *this;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                        return GetDescriptor();
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                        return default_instance().GetMetadata().descriptor;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                        return default_instance().GetMetadata().reflection;
                    }

                    static const MsgContent &default_instance() {
                        return *internal_default_instance();
                    }

                    enum ContentCase {
                        kMsg = 1,
                        CONTENT_NOT_SET = 0,
                    };

                    static inline const MsgContent *internal_default_instance() {
                        return reinterpret_cast<const MsgContent *>(
                                &_MsgContent_default_instance_);
                    }

                    static constexpr int kIndexInFileMessages =
                            3;

                    friend void swap(MsgContent &a, MsgContent &b) {
                        a.Swap(&b);
                    }

                    inline void Swap(MsgContent *other) {
                        if (other == this) return;
                        if (GetOwningArena() == other->GetOwningArena()) {
                            InternalSwap(other);
                        } else {
                            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
                        }
                    }

                    void UnsafeArenaSwap(MsgContent *other) {
                        if (other == this) return;
                        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
                        InternalSwap(other);
                    }

                    // implements Message ----------------------------------------------

                    inline MsgContent *New() const final {
                        return new MsgContent();
                    }

                    MsgContent *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                        return CreateMaybeMessage<MsgContent>(arena);
                    }

                    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void CopyFrom(const MsgContent &from);

                    void MergeFrom(const MsgContent &from);

                    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

                    bool IsInitialized() const final;

                    size_t ByteSizeLong() const final;

                    const char *
                    _InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

                    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
                            ::PROTOBUF_NAMESPACE_ID::uint8 *target,
                            ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

                    int GetCachedSize() const final { return _cached_size_.Get(); }

                private:
                    void SharedCtor();

                    void SharedDtor();

                    void SetCachedSize(int size) const final;

                    void InternalSwap(MsgContent *other);

                    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

                    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                        return "cn.tursom.im.protobuf.MsgContent";
                    }

                protected:
                    explicit MsgContent(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                private:
                    static void ArenaDtor(void *object);

                    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                public:

                    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

                    // nested types ----------------------------------------------------

                    // accessors -------------------------------------------------------

                    enum : int {
                        kMsgFieldNumber = 1,
                    };

                    // string msg = 1;
                    bool has_msg() const;

                private:
                    bool _internal_has_msg() const;

                public:
                    void clear_msg();

                    const std::string &msg() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_msg(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_msg();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_msg();

                    void set_allocated_msg(std::string *msg);

                private:
                    const std::string &_internal_msg() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(const std::string &value);

                    std::string *_internal_mutable_msg();

                public:

                    void clear_content();

                    ContentCase content_case() const;
                    // @@protoc_insertion_point(class_scope:cn.tursom.im.protobuf.MsgContent)
                private:
                    class _Internal;

                    void set_has_msg();

                    inline bool has_content() const;

                    inline void clear_has_content();

                    template<typename T> friend
                    class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;

                    typedef void InternalArenaConstructable_;
                    typedef void DestructorSkippable_;

                    union ContentUnion {
                        constexpr ContentUnion() : _constinit_{} {}

                        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
                        ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msg_;
                    } content_;

                    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
                    ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

                    friend struct ::TableStruct_TursomMsg_2eproto;
                };
// -------------------------------------------------------------------

                class SendMsgRequest final :
                        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.tursom.im.protobuf.SendMsgRequest) */ {
                public:
                    inline SendMsgRequest() : SendMsgRequest(nullptr) {}

                    ~SendMsgRequest() override;

                    explicit constexpr SendMsgRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

                    SendMsgRequest(const SendMsgRequest &from);

                    SendMsgRequest(SendMsgRequest &&from) noexcept
                            : SendMsgRequest() {
                        *this = ::std::move(from);
                    }

                    inline SendMsgRequest &operator=(const SendMsgRequest &from) {
                        CopyFrom(from);
                        return *this;
                    }

                    inline SendMsgRequest &operator=(SendMsgRequest &&from) noexcept {
                        if (this == &from) return *this;
                        if (GetOwningArena() == from.GetOwningArena()) {
                            InternalSwap(&from);
                        } else {
                            CopyFrom(from);
                        }
                        return *this;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                        return GetDescriptor();
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                        return default_instance().GetMetadata().descriptor;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                        return default_instance().GetMetadata().reflection;
                    }

                    static const SendMsgRequest &default_instance() {
                        return *internal_default_instance();
                    }

                    static inline const SendMsgRequest *internal_default_instance() {
                        return reinterpret_cast<const SendMsgRequest *>(
                                &_SendMsgRequest_default_instance_);
                    }

                    static constexpr int kIndexInFileMessages =
                            4;

                    friend void swap(SendMsgRequest &a, SendMsgRequest &b) {
                        a.Swap(&b);
                    }

                    inline void Swap(SendMsgRequest *other) {
                        if (other == this) return;
                        if (GetOwningArena() == other->GetOwningArena()) {
                            InternalSwap(other);
                        } else {
                            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
                        }
                    }

                    void UnsafeArenaSwap(SendMsgRequest *other) {
                        if (other == this) return;
                        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
                        InternalSwap(other);
                    }

                    // implements Message ----------------------------------------------

                    inline SendMsgRequest *New() const final {
                        return new SendMsgRequest();
                    }

                    SendMsgRequest *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                        return CreateMaybeMessage<SendMsgRequest>(arena);
                    }

                    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void CopyFrom(const SendMsgRequest &from);

                    void MergeFrom(const SendMsgRequest &from);

                    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

                    bool IsInitialized() const final;

                    size_t ByteSizeLong() const final;

                    const char *
                    _InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

                    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
                            ::PROTOBUF_NAMESPACE_ID::uint8 *target,
                            ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

                    int GetCachedSize() const final { return _cached_size_.Get(); }

                private:
                    void SharedCtor();

                    void SharedDtor();

                    void SetCachedSize(int size) const final;

                    void InternalSwap(SendMsgRequest *other);

                    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

                    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                        return "cn.tursom.im.protobuf.SendMsgRequest";
                    }

                protected:
                    explicit SendMsgRequest(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                private:
                    static void ArenaDtor(void *object);

                    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                public:

                    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

                    // nested types ----------------------------------------------------

                    // accessors -------------------------------------------------------

                    enum : int {
                        kReceiverFieldNumber = 1,
                        kReqIdFieldNumber = 2,
                        kContentFieldNumber = 3,
                    };

                    // string receiver = 1;
                    void clear_receiver();

                    const std::string &receiver() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_receiver(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_receiver();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_receiver();

                    void set_allocated_receiver(std::string *receiver);

                private:
                    const std::string &_internal_receiver() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(const std::string &value);

                    std::string *_internal_mutable_receiver();

                public:

                    // string reqId = 2;
                    void clear_reqid();

                    const std::string &reqid() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_reqid(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_reqid();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_reqid();

                    void set_allocated_reqid(std::string *reqid);

                private:
                    const std::string &_internal_reqid() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_reqid(const std::string &value);

                    std::string *_internal_mutable_reqid();

                public:

                    // .cn.tursom.im.protobuf.MsgContent content = 3;
                    bool has_content() const;

                private:
                    bool _internal_has_content() const;

                public:
                    void clear_content();

                    const ::cn::tursom::im::protobuf::MsgContent &content() const;

                    PROTOBUF_FUTURE_MUST_USE_RESULT ::cn::tursom::im::protobuf::MsgContent *release_content();

                    ::cn::tursom::im::protobuf::MsgContent *mutable_content();

                    void set_allocated_content(::cn::tursom::im::protobuf::MsgContent *content);

                private:
                    const ::cn::tursom::im::protobuf::MsgContent &_internal_content() const;

                    ::cn::tursom::im::protobuf::MsgContent *_internal_mutable_content();

                public:
                    void unsafe_arena_set_allocated_content(
                            ::cn::tursom::im::protobuf::MsgContent *content);

                    ::cn::tursom::im::protobuf::MsgContent *unsafe_arena_release_content();

                    // @@protoc_insertion_point(class_scope:cn.tursom.im.protobuf.SendMsgRequest)
                private:
                    class _Internal;

                    template<typename T> friend
                    class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;

                    typedef void InternalArenaConstructable_;
                    typedef void DestructorSkippable_;
                    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
                    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reqid_;
                    ::cn::tursom::im::protobuf::MsgContent *content_;
                    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
                    friend struct ::TableStruct_TursomMsg_2eproto;
                };
// -------------------------------------------------------------------

                class SendMsgResponse final :
                        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.tursom.im.protobuf.SendMsgResponse) */ {
                public:
                    inline SendMsgResponse() : SendMsgResponse(nullptr) {}

                    ~SendMsgResponse() override;

                    explicit constexpr SendMsgResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

                    SendMsgResponse(const SendMsgResponse &from);

                    SendMsgResponse(SendMsgResponse &&from) noexcept
                            : SendMsgResponse() {
                        *this = ::std::move(from);
                    }

                    inline SendMsgResponse &operator=(const SendMsgResponse &from) {
                        CopyFrom(from);
                        return *this;
                    }

                    inline SendMsgResponse &operator=(SendMsgResponse &&from) noexcept {
                        if (this == &from) return *this;
                        if (GetOwningArena() == from.GetOwningArena()) {
                            InternalSwap(&from);
                        } else {
                            CopyFrom(from);
                        }
                        return *this;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                        return GetDescriptor();
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                        return default_instance().GetMetadata().descriptor;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                        return default_instance().GetMetadata().reflection;
                    }

                    static const SendMsgResponse &default_instance() {
                        return *internal_default_instance();
                    }

                    static inline const SendMsgResponse *internal_default_instance() {
                        return reinterpret_cast<const SendMsgResponse *>(
                                &_SendMsgResponse_default_instance_);
                    }

                    static constexpr int kIndexInFileMessages =
                            5;

                    friend void swap(SendMsgResponse &a, SendMsgResponse &b) {
                        a.Swap(&b);
                    }

                    inline void Swap(SendMsgResponse *other) {
                        if (other == this) return;
                        if (GetOwningArena() == other->GetOwningArena()) {
                            InternalSwap(other);
                        } else {
                            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
                        }
                    }

                    void UnsafeArenaSwap(SendMsgResponse *other) {
                        if (other == this) return;
                        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
                        InternalSwap(other);
                    }

                    // implements Message ----------------------------------------------

                    inline SendMsgResponse *New() const final {
                        return new SendMsgResponse();
                    }

                    SendMsgResponse *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                        return CreateMaybeMessage<SendMsgResponse>(arena);
                    }

                    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void CopyFrom(const SendMsgResponse &from);

                    void MergeFrom(const SendMsgResponse &from);

                    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

                    bool IsInitialized() const final;

                    size_t ByteSizeLong() const final;

                    const char *
                    _InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

                    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
                            ::PROTOBUF_NAMESPACE_ID::uint8 *target,
                            ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

                    int GetCachedSize() const final { return _cached_size_.Get(); }

                private:
                    void SharedCtor();

                    void SharedDtor();

                    void SetCachedSize(int size) const final;

                    void InternalSwap(SendMsgResponse *other);

                    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

                    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                        return "cn.tursom.im.protobuf.SendMsgResponse";
                    }

                protected:
                    explicit SendMsgResponse(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                private:
                    static void ArenaDtor(void *object);

                    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                public:

                    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

                    // nested types ----------------------------------------------------

                    // accessors -------------------------------------------------------

                    enum : int {
                        kReceiverFieldNumber = 1,
                        kReqIdFieldNumber = 2,
                        kFailMsgFieldNumber = 4,
                        kSuccessFieldNumber = 3,
                        kFailTypeFieldNumber = 5,
                    };

                    // string receiver = 1;
                    void clear_receiver();

                    const std::string &receiver() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_receiver(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_receiver();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_receiver();

                    void set_allocated_receiver(std::string *receiver);

                private:
                    const std::string &_internal_receiver() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(const std::string &value);

                    std::string *_internal_mutable_receiver();

                public:

                    // string reqId = 2;
                    void clear_reqid();

                    const std::string &reqid() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_reqid(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_reqid();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_reqid();

                    void set_allocated_reqid(std::string *reqid);

                private:
                    const std::string &_internal_reqid() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_reqid(const std::string &value);

                    std::string *_internal_mutable_reqid();

                public:

                    // string failMsg = 4;
                    void clear_failmsg();

                    const std::string &failmsg() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_failmsg(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_failmsg();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_failmsg();

                    void set_allocated_failmsg(std::string *failmsg);

                private:
                    const std::string &_internal_failmsg() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_failmsg(const std::string &value);

                    std::string *_internal_mutable_failmsg();

                public:

                    // bool success = 3;
                    void clear_success();

                    bool success() const;

                    void set_success(bool value);

                private:
                    bool _internal_success() const;

                    void _internal_set_success(bool value);

                public:

                    // .cn.tursom.im.protobuf.FailType failType = 5;
                    void clear_failtype();

                    ::cn::tursom::im::protobuf::FailType failtype() const;

                    void set_failtype(::cn::tursom::im::protobuf::FailType value);

                private:
                    ::cn::tursom::im::protobuf::FailType _internal_failtype() const;

                    void _internal_set_failtype(::cn::tursom::im::protobuf::FailType value);

                public:

                    // @@protoc_insertion_point(class_scope:cn.tursom.im.protobuf.SendMsgResponse)
                private:
                    class _Internal;

                    template<typename T> friend
                    class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;

                    typedef void InternalArenaConstructable_;
                    typedef void DestructorSkippable_;
                    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
                    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reqid_;
                    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr failmsg_;
                    bool success_;
                    int failtype_;
                    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
                    friend struct ::TableStruct_TursomMsg_2eproto;
                };
// -------------------------------------------------------------------

                class ChatMsg final :
                        public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:cn.tursom.im.protobuf.ChatMsg) */ {
                public:
                    inline ChatMsg() : ChatMsg(nullptr) {}

                    ~ChatMsg() override;

                    explicit constexpr ChatMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

                    ChatMsg(const ChatMsg &from);

                    ChatMsg(ChatMsg &&from) noexcept
                            : ChatMsg() {
                        *this = ::std::move(from);
                    }

                    inline ChatMsg &operator=(const ChatMsg &from) {
                        CopyFrom(from);
                        return *this;
                    }

                    inline ChatMsg &operator=(ChatMsg &&from) noexcept {
                        if (this == &from) return *this;
                        if (GetOwningArena() == from.GetOwningArena()) {
                            InternalSwap(&from);
                        } else {
                            CopyFrom(from);
                        }
                        return *this;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *descriptor() {
                        return GetDescriptor();
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Descriptor *GetDescriptor() {
                        return default_instance().GetMetadata().descriptor;
                    }

                    static const ::PROTOBUF_NAMESPACE_ID::Reflection *GetReflection() {
                        return default_instance().GetMetadata().reflection;
                    }

                    static const ChatMsg &default_instance() {
                        return *internal_default_instance();
                    }

                    static inline const ChatMsg *internal_default_instance() {
                        return reinterpret_cast<const ChatMsg *>(
                                &_ChatMsg_default_instance_);
                    }

                    static constexpr int kIndexInFileMessages =
                            6;

                    friend void swap(ChatMsg &a, ChatMsg &b) {
                        a.Swap(&b);
                    }

                    inline void Swap(ChatMsg *other) {
                        if (other == this) return;
                        if (GetOwningArena() == other->GetOwningArena()) {
                            InternalSwap(other);
                        } else {
                            ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
                        }
                    }

                    void UnsafeArenaSwap(ChatMsg *other) {
                        if (other == this) return;
                        GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
                        InternalSwap(other);
                    }

                    // implements Message ----------------------------------------------

                    inline ChatMsg *New() const final {
                        return new ChatMsg();
                    }

                    ChatMsg *New(::PROTOBUF_NAMESPACE_ID::Arena *arena) const final {
                        return CreateMaybeMessage<ChatMsg>(arena);
                    }

                    void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) final;

                    void CopyFrom(const ChatMsg &from);

                    void MergeFrom(const ChatMsg &from);

                    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;

                    bool IsInitialized() const final;

                    size_t ByteSizeLong() const final;

                    const char *
                    _InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) final;

                    ::PROTOBUF_NAMESPACE_ID::uint8 *_InternalSerialize(
                            ::PROTOBUF_NAMESPACE_ID::uint8 *target,
                            ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const final;

                    int GetCachedSize() const final { return _cached_size_.Get(); }

                private:
                    void SharedCtor();

                    void SharedDtor();

                    void SetCachedSize(int size) const final;

                    void InternalSwap(ChatMsg *other);

                    friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;

                    static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
                        return "cn.tursom.im.protobuf.ChatMsg";
                    }

                protected:
                    explicit ChatMsg(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                private:
                    static void ArenaDtor(void *object);

                    inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *arena);

                public:

                    ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

                    // nested types ----------------------------------------------------

                    // accessors -------------------------------------------------------

                    enum : int {
                        kReceiverFieldNumber = 1,
                        kSenderFieldNumber = 2,
                        kContentFieldNumber = 3,
                    };

                    // string receiver = 1;
                    void clear_receiver();

                    const std::string &receiver() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_receiver(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_receiver();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_receiver();

                    void set_allocated_receiver(std::string *receiver);

                private:
                    const std::string &_internal_receiver() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(const std::string &value);

                    std::string *_internal_mutable_receiver();

                public:

                    // string sender = 2;
                    void clear_sender();

                    const std::string &sender() const;

                    template<typename ArgT0 = const std::string &, typename... ArgT>
                    void set_sender(ArgT0 &&arg0, ArgT... args);

                    std::string *mutable_sender();

                    PROTOBUF_FUTURE_MUST_USE_RESULT std::string *release_sender();

                    void set_allocated_sender(std::string *sender);

                private:
                    const std::string &_internal_sender() const;

                    inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender(const std::string &value);

                    std::string *_internal_mutable_sender();

                public:

                    // .cn.tursom.im.protobuf.MsgContent content = 3;
                    bool has_content() const;

                private:
                    bool _internal_has_content() const;

                public:
                    void clear_content();

                    const ::cn::tursom::im::protobuf::MsgContent &content() const;

                    PROTOBUF_FUTURE_MUST_USE_RESULT ::cn::tursom::im::protobuf::MsgContent *release_content();

                    ::cn::tursom::im::protobuf::MsgContent *mutable_content();

                    void set_allocated_content(::cn::tursom::im::protobuf::MsgContent *content);

                private:
                    const ::cn::tursom::im::protobuf::MsgContent &_internal_content() const;

                    ::cn::tursom::im::protobuf::MsgContent *_internal_mutable_content();

                public:
                    void unsafe_arena_set_allocated_content(
                            ::cn::tursom::im::protobuf::MsgContent *content);

                    ::cn::tursom::im::protobuf::MsgContent *unsafe_arena_release_content();

                    // @@protoc_insertion_point(class_scope:cn.tursom.im.protobuf.ChatMsg)
                private:
                    class _Internal;

                    template<typename T> friend
                    class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;

                    typedef void InternalArenaConstructable_;
                    typedef void DestructorSkippable_;
                    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
                    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_;
                    ::cn::tursom::im::protobuf::MsgContent *content_;
                    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
                    friend struct ::TableStruct_TursomMsg_2eproto;
                };
// ===================================================================


// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ImMsg

// string msgId = 1;
                inline void ImMsg::clear_msgid() {
                    msgid_.ClearToEmpty();
                }

                inline const std::string &ImMsg::msgid() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.ImMsg.msgId)
                    return _internal_msgid();
                }

                template<typename ArgT0, typename... ArgT>
                inline PROTOBUF_ALWAYS_INLINE
                void ImMsg::set_msgid(ArgT0 &&arg0, ArgT... args) {
                    msgid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                               static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.ImMsg.msgId)
                }

                inline std::string *ImMsg::mutable_msgid() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.ImMsg.msgId)
                    return _internal_mutable_msgid();
                }

                inline const std::string &ImMsg::_internal_msgid() const {
                    return msgid_.Get();
                }

                inline void ImMsg::_internal_set_msgid(const std::string &value) {

                    msgid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                               GetArenaForAllocation());
                }

                inline std::string *ImMsg::_internal_mutable_msgid() {

                    return msgid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                          GetArenaForAllocation());
                }

                inline std::string *ImMsg::release_msgid() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.ImMsg.msgId)
                    return msgid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                          GetArenaForAllocation());
                }

                inline void ImMsg::set_allocated_msgid(std::string *msgid) {
                    if (msgid != nullptr) {

                    } else {

                    }
                    msgid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msgid,
                                        GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.ImMsg.msgId)
                }

// bool selfMsg = 7;
                inline void ImMsg::clear_selfmsg() {
                    selfmsg_ = false;
                }

                inline bool ImMsg::_internal_selfmsg() const {
                    return selfmsg_;
                }

                inline bool ImMsg::selfmsg() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.ImMsg.selfMsg)
                    return _internal_selfmsg();
                }

                inline void ImMsg::_internal_set_selfmsg(bool value) {

                    selfmsg_ = value;
                }

                inline void ImMsg::set_selfmsg(bool value) {
                    _internal_set_selfmsg(value);
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.ImMsg.selfMsg)
                }

// .cn.tursom.im.protobuf.LoginRequest loginRequest = 2;
                inline bool ImMsg::_internal_has_loginrequest() const {
                    return content_case() == kLoginRequest;
                }

                inline bool ImMsg::has_loginrequest() const {
                    return _internal_has_loginrequest();
                }

                inline void ImMsg::set_has_loginrequest() {
                    _oneof_case_[0] = kLoginRequest;
                }

                inline void ImMsg::clear_loginrequest() {
                    if (_internal_has_loginrequest()) {
                        if (GetArenaForAllocation() == nullptr) {
                            delete content_.loginrequest_;
                        }
                        clear_has_content();
                    }
                }

                inline ::cn::tursom::im::protobuf::LoginRequest *ImMsg::release_loginrequest() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.ImMsg.loginRequest)
                    if (_internal_has_loginrequest()) {
                        clear_has_content();
                        ::cn::tursom::im::protobuf::LoginRequest *temp = content_.loginrequest_;
                        if (GetArenaForAllocation() != nullptr) {
                            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
                        }
                        content_.loginrequest_ = nullptr;
                        return temp;
                    } else {
                        return nullptr;
                    }
                }

                inline const ::cn::tursom::im::protobuf::LoginRequest &ImMsg::_internal_loginrequest() const {
                    return _internal_has_loginrequest()
                           ? *content_.loginrequest_
                           : reinterpret_cast< ::cn::tursom::im::protobuf::LoginRequest &>(::cn::tursom::im::protobuf::_LoginRequest_default_instance_);
                }

                inline const ::cn::tursom::im::protobuf::LoginRequest &ImMsg::loginrequest() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.ImMsg.loginRequest)
                    return _internal_loginrequest();
                }

                inline ::cn::tursom::im::protobuf::LoginRequest *ImMsg::unsafe_arena_release_loginrequest() {
                    // @@protoc_insertion_point(field_unsafe_arena_release:cn.tursom.im.protobuf.ImMsg.loginRequest)
                    if (_internal_has_loginrequest()) {
                        clear_has_content();
                        ::cn::tursom::im::protobuf::LoginRequest *temp = content_.loginrequest_;
                        content_.loginrequest_ = nullptr;
                        return temp;
                    } else {
                        return nullptr;
                    }
                }

                inline void
                ImMsg::unsafe_arena_set_allocated_loginrequest(::cn::tursom::im::protobuf::LoginRequest *loginrequest) {
                    clear_content();
                    if (loginrequest) {
                        set_has_loginrequest();
                        content_.loginrequest_ = loginrequest;
                    }
                    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.tursom.im.protobuf.ImMsg.loginRequest)
                }

                inline ::cn::tursom::im::protobuf::LoginRequest *ImMsg::_internal_mutable_loginrequest() {
                    if (!_internal_has_loginrequest()) {
                        clear_content();
                        set_has_loginrequest();
                        content_.loginrequest_ = CreateMaybeMessage<::cn::tursom::im::protobuf::LoginRequest>(
                                GetArenaForAllocation());
                    }
                    return content_.loginrequest_;
                }

                inline ::cn::tursom::im::protobuf::LoginRequest *ImMsg::mutable_loginrequest() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.ImMsg.loginRequest)
                    return _internal_mutable_loginrequest();
                }

// .cn.tursom.im.protobuf.LoginResult loginResult = 3;
                inline bool ImMsg::_internal_has_loginresult() const {
                    return content_case() == kLoginResult;
                }

                inline bool ImMsg::has_loginresult() const {
                    return _internal_has_loginresult();
                }

                inline void ImMsg::set_has_loginresult() {
                    _oneof_case_[0] = kLoginResult;
                }

                inline void ImMsg::clear_loginresult() {
                    if (_internal_has_loginresult()) {
                        if (GetArenaForAllocation() == nullptr) {
                            delete content_.loginresult_;
                        }
                        clear_has_content();
                    }
                }

                inline ::cn::tursom::im::protobuf::LoginResult *ImMsg::release_loginresult() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.ImMsg.loginResult)
                    if (_internal_has_loginresult()) {
                        clear_has_content();
                        ::cn::tursom::im::protobuf::LoginResult *temp = content_.loginresult_;
                        if (GetArenaForAllocation() != nullptr) {
                            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
                        }
                        content_.loginresult_ = nullptr;
                        return temp;
                    } else {
                        return nullptr;
                    }
                }

                inline const ::cn::tursom::im::protobuf::LoginResult &ImMsg::_internal_loginresult() const {
                    return _internal_has_loginresult()
                           ? *content_.loginresult_
                           : reinterpret_cast< ::cn::tursom::im::protobuf::LoginResult &>(::cn::tursom::im::protobuf::_LoginResult_default_instance_);
                }

                inline const ::cn::tursom::im::protobuf::LoginResult &ImMsg::loginresult() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.ImMsg.loginResult)
                    return _internal_loginresult();
                }

                inline ::cn::tursom::im::protobuf::LoginResult *ImMsg::unsafe_arena_release_loginresult() {
                    // @@protoc_insertion_point(field_unsafe_arena_release:cn.tursom.im.protobuf.ImMsg.loginResult)
                    if (_internal_has_loginresult()) {
                        clear_has_content();
                        ::cn::tursom::im::protobuf::LoginResult *temp = content_.loginresult_;
                        content_.loginresult_ = nullptr;
                        return temp;
                    } else {
                        return nullptr;
                    }
                }

                inline void
                ImMsg::unsafe_arena_set_allocated_loginresult(::cn::tursom::im::protobuf::LoginResult *loginresult) {
                    clear_content();
                    if (loginresult) {
                        set_has_loginresult();
                        content_.loginresult_ = loginresult;
                    }
                    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.tursom.im.protobuf.ImMsg.loginResult)
                }

                inline ::cn::tursom::im::protobuf::LoginResult *ImMsg::_internal_mutable_loginresult() {
                    if (!_internal_has_loginresult()) {
                        clear_content();
                        set_has_loginresult();
                        content_.loginresult_ = CreateMaybeMessage<::cn::tursom::im::protobuf::LoginResult>(
                                GetArenaForAllocation());
                    }
                    return content_.loginresult_;
                }

                inline ::cn::tursom::im::protobuf::LoginResult *ImMsg::mutable_loginresult() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.ImMsg.loginResult)
                    return _internal_mutable_loginresult();
                }

// .cn.tursom.im.protobuf.ChatMsg chatMsg = 4;
                inline bool ImMsg::_internal_has_chatmsg() const {
                    return content_case() == kChatMsg;
                }

                inline bool ImMsg::has_chatmsg() const {
                    return _internal_has_chatmsg();
                }

                inline void ImMsg::set_has_chatmsg() {
                    _oneof_case_[0] = kChatMsg;
                }

                inline void ImMsg::clear_chatmsg() {
                    if (_internal_has_chatmsg()) {
                        if (GetArenaForAllocation() == nullptr) {
                            delete content_.chatmsg_;
                        }
                        clear_has_content();
                    }
                }

                inline ::cn::tursom::im::protobuf::ChatMsg *ImMsg::release_chatmsg() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.ImMsg.chatMsg)
                    if (_internal_has_chatmsg()) {
                        clear_has_content();
                        ::cn::tursom::im::protobuf::ChatMsg *temp = content_.chatmsg_;
                        if (GetArenaForAllocation() != nullptr) {
                            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
                        }
                        content_.chatmsg_ = nullptr;
                        return temp;
                    } else {
                        return nullptr;
                    }
                }

                inline const ::cn::tursom::im::protobuf::ChatMsg &ImMsg::_internal_chatmsg() const {
                    return _internal_has_chatmsg()
                           ? *content_.chatmsg_
                           : reinterpret_cast< ::cn::tursom::im::protobuf::ChatMsg &>(::cn::tursom::im::protobuf::_ChatMsg_default_instance_);
                }

                inline const ::cn::tursom::im::protobuf::ChatMsg &ImMsg::chatmsg() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.ImMsg.chatMsg)
                    return _internal_chatmsg();
                }

                inline ::cn::tursom::im::protobuf::ChatMsg *ImMsg::unsafe_arena_release_chatmsg() {
                    // @@protoc_insertion_point(field_unsafe_arena_release:cn.tursom.im.protobuf.ImMsg.chatMsg)
                    if (_internal_has_chatmsg()) {
                        clear_has_content();
                        ::cn::tursom::im::protobuf::ChatMsg *temp = content_.chatmsg_;
                        content_.chatmsg_ = nullptr;
                        return temp;
                    } else {
                        return nullptr;
                    }
                }

                inline void ImMsg::unsafe_arena_set_allocated_chatmsg(::cn::tursom::im::protobuf::ChatMsg *chatmsg) {
                    clear_content();
                    if (chatmsg) {
                        set_has_chatmsg();
                        content_.chatmsg_ = chatmsg;
                    }
                    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.tursom.im.protobuf.ImMsg.chatMsg)
                }

                inline ::cn::tursom::im::protobuf::ChatMsg *ImMsg::_internal_mutable_chatmsg() {
                    if (!_internal_has_chatmsg()) {
                        clear_content();
                        set_has_chatmsg();
                        content_.chatmsg_ = CreateMaybeMessage<::cn::tursom::im::protobuf::ChatMsg>(
                                GetArenaForAllocation());
                    }
                    return content_.chatmsg_;
                }

                inline ::cn::tursom::im::protobuf::ChatMsg *ImMsg::mutable_chatmsg() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.ImMsg.chatMsg)
                    return _internal_mutable_chatmsg();
                }

// .cn.tursom.im.protobuf.SendMsgRequest sendMsgRequest = 5;
                inline bool ImMsg::_internal_has_sendmsgrequest() const {
                    return content_case() == kSendMsgRequest;
                }

                inline bool ImMsg::has_sendmsgrequest() const {
                    return _internal_has_sendmsgrequest();
                }

                inline void ImMsg::set_has_sendmsgrequest() {
                    _oneof_case_[0] = kSendMsgRequest;
                }

                inline void ImMsg::clear_sendmsgrequest() {
                    if (_internal_has_sendmsgrequest()) {
                        if (GetArenaForAllocation() == nullptr) {
                            delete content_.sendmsgrequest_;
                        }
                        clear_has_content();
                    }
                }

                inline ::cn::tursom::im::protobuf::SendMsgRequest *ImMsg::release_sendmsgrequest() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.ImMsg.sendMsgRequest)
                    if (_internal_has_sendmsgrequest()) {
                        clear_has_content();
                        ::cn::tursom::im::protobuf::SendMsgRequest *temp = content_.sendmsgrequest_;
                        if (GetArenaForAllocation() != nullptr) {
                            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
                        }
                        content_.sendmsgrequest_ = nullptr;
                        return temp;
                    } else {
                        return nullptr;
                    }
                }

                inline const ::cn::tursom::im::protobuf::SendMsgRequest &ImMsg::_internal_sendmsgrequest() const {
                    return _internal_has_sendmsgrequest()
                           ? *content_.sendmsgrequest_
                           : reinterpret_cast< ::cn::tursom::im::protobuf::SendMsgRequest &>(::cn::tursom::im::protobuf::_SendMsgRequest_default_instance_);
                }

                inline const ::cn::tursom::im::protobuf::SendMsgRequest &ImMsg::sendmsgrequest() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.ImMsg.sendMsgRequest)
                    return _internal_sendmsgrequest();
                }

                inline ::cn::tursom::im::protobuf::SendMsgRequest *ImMsg::unsafe_arena_release_sendmsgrequest() {
                    // @@protoc_insertion_point(field_unsafe_arena_release:cn.tursom.im.protobuf.ImMsg.sendMsgRequest)
                    if (_internal_has_sendmsgrequest()) {
                        clear_has_content();
                        ::cn::tursom::im::protobuf::SendMsgRequest *temp = content_.sendmsgrequest_;
                        content_.sendmsgrequest_ = nullptr;
                        return temp;
                    } else {
                        return nullptr;
                    }
                }

                inline void ImMsg::unsafe_arena_set_allocated_sendmsgrequest(
                        ::cn::tursom::im::protobuf::SendMsgRequest *sendmsgrequest) {
                    clear_content();
                    if (sendmsgrequest) {
                        set_has_sendmsgrequest();
                        content_.sendmsgrequest_ = sendmsgrequest;
                    }
                    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.tursom.im.protobuf.ImMsg.sendMsgRequest)
                }

                inline ::cn::tursom::im::protobuf::SendMsgRequest *ImMsg::_internal_mutable_sendmsgrequest() {
                    if (!_internal_has_sendmsgrequest()) {
                        clear_content();
                        set_has_sendmsgrequest();
                        content_.sendmsgrequest_ = CreateMaybeMessage<::cn::tursom::im::protobuf::SendMsgRequest>(
                                GetArenaForAllocation());
                    }
                    return content_.sendmsgrequest_;
                }

                inline ::cn::tursom::im::protobuf::SendMsgRequest *ImMsg::mutable_sendmsgrequest() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.ImMsg.sendMsgRequest)
                    return _internal_mutable_sendmsgrequest();
                }

// .cn.tursom.im.protobuf.SendMsgResponse sendMsgResponse = 6;
                inline bool ImMsg::_internal_has_sendmsgresponse() const {
                    return content_case() == kSendMsgResponse;
                }

                inline bool ImMsg::has_sendmsgresponse() const {
                    return _internal_has_sendmsgresponse();
                }

                inline void ImMsg::set_has_sendmsgresponse() {
                    _oneof_case_[0] = kSendMsgResponse;
                }

                inline void ImMsg::clear_sendmsgresponse() {
                    if (_internal_has_sendmsgresponse()) {
                        if (GetArenaForAllocation() == nullptr) {
                            delete content_.sendmsgresponse_;
                        }
                        clear_has_content();
                    }
                }

                inline ::cn::tursom::im::protobuf::SendMsgResponse *ImMsg::release_sendmsgresponse() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.ImMsg.sendMsgResponse)
                    if (_internal_has_sendmsgresponse()) {
                        clear_has_content();
                        ::cn::tursom::im::protobuf::SendMsgResponse *temp = content_.sendmsgresponse_;
                        if (GetArenaForAllocation() != nullptr) {
                            temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
                        }
                        content_.sendmsgresponse_ = nullptr;
                        return temp;
                    } else {
                        return nullptr;
                    }
                }

                inline const ::cn::tursom::im::protobuf::SendMsgResponse &ImMsg::_internal_sendmsgresponse() const {
                    return _internal_has_sendmsgresponse()
                           ? *content_.sendmsgresponse_
                           : reinterpret_cast< ::cn::tursom::im::protobuf::SendMsgResponse &>(::cn::tursom::im::protobuf::_SendMsgResponse_default_instance_);
                }

                inline const ::cn::tursom::im::protobuf::SendMsgResponse &ImMsg::sendmsgresponse() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.ImMsg.sendMsgResponse)
                    return _internal_sendmsgresponse();
                }

                inline ::cn::tursom::im::protobuf::SendMsgResponse *ImMsg::unsafe_arena_release_sendmsgresponse() {
                    // @@protoc_insertion_point(field_unsafe_arena_release:cn.tursom.im.protobuf.ImMsg.sendMsgResponse)
                    if (_internal_has_sendmsgresponse()) {
                        clear_has_content();
                        ::cn::tursom::im::protobuf::SendMsgResponse *temp = content_.sendmsgresponse_;
                        content_.sendmsgresponse_ = nullptr;
                        return temp;
                    } else {
                        return nullptr;
                    }
                }

                inline void ImMsg::unsafe_arena_set_allocated_sendmsgresponse(
                        ::cn::tursom::im::protobuf::SendMsgResponse *sendmsgresponse) {
                    clear_content();
                    if (sendmsgresponse) {
                        set_has_sendmsgresponse();
                        content_.sendmsgresponse_ = sendmsgresponse;
                    }
                    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.tursom.im.protobuf.ImMsg.sendMsgResponse)
                }

                inline ::cn::tursom::im::protobuf::SendMsgResponse *ImMsg::_internal_mutable_sendmsgresponse() {
                    if (!_internal_has_sendmsgresponse()) {
                        clear_content();
                        set_has_sendmsgresponse();
                        content_.sendmsgresponse_ = CreateMaybeMessage<::cn::tursom::im::protobuf::SendMsgResponse>(
                                GetArenaForAllocation());
                    }
                    return content_.sendmsgresponse_;
                }

                inline ::cn::tursom::im::protobuf::SendMsgResponse *ImMsg::mutable_sendmsgresponse() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.ImMsg.sendMsgResponse)
                    return _internal_mutable_sendmsgresponse();
                }

// string heartBeat = 8;
                inline bool ImMsg::_internal_has_heartbeat() const {
                    return content_case() == kHeartBeat;
                }

                inline bool ImMsg::has_heartbeat() const {
                    return _internal_has_heartbeat();
                }

                inline void ImMsg::set_has_heartbeat() {
                    _oneof_case_[0] = kHeartBeat;
                }

                inline void ImMsg::clear_heartbeat() {
                    if (_internal_has_heartbeat()) {
                        content_.heartbeat_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                                    GetArenaForAllocation());
                        clear_has_content();
                    }
                }

                inline const std::string &ImMsg::heartbeat() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.ImMsg.heartBeat)
                    return _internal_heartbeat();
                }

                template<typename ArgT0, typename... ArgT>
                inline void ImMsg::set_heartbeat(ArgT0 &&arg0, ArgT... args) {
                    if (!_internal_has_heartbeat()) {
                        clear_content();
                        set_has_heartbeat();
                        content_.heartbeat_.UnsafeSetDefault(
                                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
                    }
                    content_.heartbeat_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                            static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.ImMsg.heartBeat)
                }

                inline std::string *ImMsg::mutable_heartbeat() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.ImMsg.heartBeat)
                    return _internal_mutable_heartbeat();
                }

                inline const std::string &ImMsg::_internal_heartbeat() const {
                    if (_internal_has_heartbeat()) {
                        return content_.heartbeat_.Get();
                    }
                    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
                }

                inline void ImMsg::_internal_set_heartbeat(const std::string &value) {
                    if (!_internal_has_heartbeat()) {
                        clear_content();
                        set_has_heartbeat();
                        content_.heartbeat_.UnsafeSetDefault(
                                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
                    }
                    content_.heartbeat_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                                            GetArenaForAllocation());
                }

                inline std::string *ImMsg::_internal_mutable_heartbeat() {
                    if (!_internal_has_heartbeat()) {
                        clear_content();
                        set_has_heartbeat();
                        content_.heartbeat_.UnsafeSetDefault(
                                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
                    }
                    return content_.heartbeat_.Mutable(
                            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
                }

                inline std::string *ImMsg::release_heartbeat() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.ImMsg.heartBeat)
                    if (_internal_has_heartbeat()) {
                        clear_has_content();
                        return content_.heartbeat_.ReleaseNonDefault(
                                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                GetArenaForAllocation());
                    } else {
                        return nullptr;
                    }
                }

                inline void ImMsg::set_allocated_heartbeat(std::string *heartbeat) {
                    if (has_content()) {
                        clear_content();
                    }
                    if (heartbeat != nullptr) {
                        set_has_heartbeat();
                        content_.heartbeat_.UnsafeSetDefault(heartbeat);
                        ::PROTOBUF_NAMESPACE_ID::Arena *arena = GetArenaForAllocation();
                        if (arena != nullptr) {
                            arena->Own(heartbeat);
                        }
                    }
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.ImMsg.heartBeat)
                }

                inline bool ImMsg::has_content() const {
                    return content_case() != CONTENT_NOT_SET;
                }

                inline void ImMsg::clear_has_content() {
                    _oneof_case_[0] = CONTENT_NOT_SET;
                }

                inline ImMsg::ContentCase ImMsg::content_case() const {
                    return ImMsg::ContentCase(_oneof_case_[0]);
                }
// -------------------------------------------------------------------

// LoginRequest

// string token = 1;
                inline void LoginRequest::clear_token() {
                    token_.ClearToEmpty();
                }

                inline const std::string &LoginRequest::token() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.LoginRequest.token)
                    return _internal_token();
                }

                template<typename ArgT0, typename... ArgT>
                inline PROTOBUF_ALWAYS_INLINE
                void LoginRequest::set_token(ArgT0 &&arg0, ArgT... args) {

                    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                               static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.LoginRequest.token)
                }

                inline std::string *LoginRequest::mutable_token() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.LoginRequest.token)
                    return _internal_mutable_token();
                }

                inline const std::string &LoginRequest::_internal_token() const {
                    return token_.Get();
                }

                inline void LoginRequest::_internal_set_token(const std::string &value) {

                    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                               GetArenaForAllocation());
                }

                inline std::string *LoginRequest::_internal_mutable_token() {

                    return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                          GetArenaForAllocation());
                }

                inline std::string *LoginRequest::release_token() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.LoginRequest.token)
                    return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                          GetArenaForAllocation());
                }

                inline void LoginRequest::set_allocated_token(std::string *token) {
                    if (token != nullptr) {

                    } else {

                    }
                    token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
                                        GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.LoginRequest.token)
                }

// -------------------------------------------------------------------

// LoginResult

// bool success = 1;
                inline void LoginResult::clear_success() {
                    success_ = false;
                }

                inline bool LoginResult::_internal_success() const {
                    return success_;
                }

                inline bool LoginResult::success() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.LoginResult.success)
                    return _internal_success();
                }

                inline void LoginResult::_internal_set_success(bool value) {

                    success_ = value;
                }

                inline void LoginResult::set_success(bool value) {
                    _internal_set_success(value);
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.LoginResult.success)
                }

// string imUserId = 2;
                inline void LoginResult::clear_imuserid() {
                    imuserid_.ClearToEmpty();
                }

                inline const std::string &LoginResult::imuserid() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.LoginResult.imUserId)
                    return _internal_imuserid();
                }

                template<typename ArgT0, typename... ArgT>
                inline PROTOBUF_ALWAYS_INLINE
                void LoginResult::set_imuserid(ArgT0 &&arg0, ArgT... args) {

                    imuserid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                  static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.LoginResult.imUserId)
                }

                inline std::string *LoginResult::mutable_imuserid() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.LoginResult.imUserId)
                    return _internal_mutable_imuserid();
                }

                inline const std::string &LoginResult::_internal_imuserid() const {
                    return imuserid_.Get();
                }

                inline void LoginResult::_internal_set_imuserid(const std::string &value) {

                    imuserid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                                  GetArenaForAllocation());
                }

                inline std::string *LoginResult::_internal_mutable_imuserid() {

                    return imuserid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                             GetArenaForAllocation());
                }

                inline std::string *LoginResult::release_imuserid() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.LoginResult.imUserId)
                    return imuserid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                             GetArenaForAllocation());
                }

                inline void LoginResult::set_allocated_imuserid(std::string *imuserid) {
                    if (imuserid != nullptr) {

                    } else {

                    }
                    imuserid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), imuserid,
                                           GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.LoginResult.imUserId)
                }

// -------------------------------------------------------------------

// MsgContent

// string msg = 1;
                inline bool MsgContent::_internal_has_msg() const {
                    return content_case() == kMsg;
                }

                inline bool MsgContent::has_msg() const {
                    return _internal_has_msg();
                }

                inline void MsgContent::set_has_msg() {
                    _oneof_case_[0] = kMsg;
                }

                inline void MsgContent::clear_msg() {
                    if (_internal_has_msg()) {
                        content_.msg_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                              GetArenaForAllocation());
                        clear_has_content();
                    }
                }

                inline const std::string &MsgContent::msg() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.MsgContent.msg)
                    return _internal_msg();
                }

                template<typename ArgT0, typename... ArgT>
                inline void MsgContent::set_msg(ArgT0 &&arg0, ArgT... args) {
                    if (!_internal_has_msg()) {
                        clear_content();
                        set_has_msg();
                        content_.msg_.UnsafeSetDefault(
                                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
                    }
                    content_.msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                      static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.MsgContent.msg)
                }

                inline std::string *MsgContent::mutable_msg() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.MsgContent.msg)
                    return _internal_mutable_msg();
                }

                inline const std::string &MsgContent::_internal_msg() const {
                    if (_internal_has_msg()) {
                        return content_.msg_.Get();
                    }
                    return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
                }

                inline void MsgContent::_internal_set_msg(const std::string &value) {
                    if (!_internal_has_msg()) {
                        clear_content();
                        set_has_msg();
                        content_.msg_.UnsafeSetDefault(
                                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
                    }
                    content_.msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                                      GetArenaForAllocation());
                }

                inline std::string *MsgContent::_internal_mutable_msg() {
                    if (!_internal_has_msg()) {
                        clear_content();
                        set_has_msg();
                        content_.msg_.UnsafeSetDefault(
                                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
                    }
                    return content_.msg_.Mutable(
                            ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
                }

                inline std::string *MsgContent::release_msg() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.MsgContent.msg)
                    if (_internal_has_msg()) {
                        clear_has_content();
                        return content_.msg_.ReleaseNonDefault(
                                &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                GetArenaForAllocation());
                    } else {
                        return nullptr;
                    }
                }

                inline void MsgContent::set_allocated_msg(std::string *msg) {
                    if (has_content()) {
                        clear_content();
                    }
                    if (msg != nullptr) {
                        set_has_msg();
                        content_.msg_.UnsafeSetDefault(msg);
                        ::PROTOBUF_NAMESPACE_ID::Arena *arena = GetArenaForAllocation();
                        if (arena != nullptr) {
                            arena->Own(msg);
                        }
                    }
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.MsgContent.msg)
                }

                inline bool MsgContent::has_content() const {
                    return content_case() != CONTENT_NOT_SET;
                }

                inline void MsgContent::clear_has_content() {
                    _oneof_case_[0] = CONTENT_NOT_SET;
                }

                inline MsgContent::ContentCase MsgContent::content_case() const {
                    return MsgContent::ContentCase(_oneof_case_[0]);
                }
// -------------------------------------------------------------------

// SendMsgRequest

// string receiver = 1;
                inline void SendMsgRequest::clear_receiver() {
                    receiver_.ClearToEmpty();
                }

                inline const std::string &SendMsgRequest::receiver() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.SendMsgRequest.receiver)
                    return _internal_receiver();
                }

                template<typename ArgT0, typename... ArgT>
                inline PROTOBUF_ALWAYS_INLINE
                void SendMsgRequest::set_receiver(ArgT0 &&arg0, ArgT... args) {

                    receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                  static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.SendMsgRequest.receiver)
                }

                inline std::string *SendMsgRequest::mutable_receiver() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.SendMsgRequest.receiver)
                    return _internal_mutable_receiver();
                }

                inline const std::string &SendMsgRequest::_internal_receiver() const {
                    return receiver_.Get();
                }

                inline void SendMsgRequest::_internal_set_receiver(const std::string &value) {

                    receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                                  GetArenaForAllocation());
                }

                inline std::string *SendMsgRequest::_internal_mutable_receiver() {

                    return receiver_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                             GetArenaForAllocation());
                }

                inline std::string *SendMsgRequest::release_receiver() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.SendMsgRequest.receiver)
                    return receiver_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                             GetArenaForAllocation());
                }

                inline void SendMsgRequest::set_allocated_receiver(std::string *receiver) {
                    if (receiver != nullptr) {

                    } else {

                    }
                    receiver_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver,
                                           GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.SendMsgRequest.receiver)
                }

// string reqId = 2;
                inline void SendMsgRequest::clear_reqid() {
                    reqid_.ClearToEmpty();
                }

                inline const std::string &SendMsgRequest::reqid() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.SendMsgRequest.reqId)
                    return _internal_reqid();
                }

                template<typename ArgT0, typename... ArgT>
                inline PROTOBUF_ALWAYS_INLINE
                void SendMsgRequest::set_reqid(ArgT0 &&arg0, ArgT... args) {

                    reqid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                               static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.SendMsgRequest.reqId)
                }

                inline std::string *SendMsgRequest::mutable_reqid() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.SendMsgRequest.reqId)
                    return _internal_mutable_reqid();
                }

                inline const std::string &SendMsgRequest::_internal_reqid() const {
                    return reqid_.Get();
                }

                inline void SendMsgRequest::_internal_set_reqid(const std::string &value) {

                    reqid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                               GetArenaForAllocation());
                }

                inline std::string *SendMsgRequest::_internal_mutable_reqid() {

                    return reqid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                          GetArenaForAllocation());
                }

                inline std::string *SendMsgRequest::release_reqid() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.SendMsgRequest.reqId)
                    return reqid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                          GetArenaForAllocation());
                }

                inline void SendMsgRequest::set_allocated_reqid(std::string *reqid) {
                    if (reqid != nullptr) {

                    } else {

                    }
                    reqid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reqid,
                                        GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.SendMsgRequest.reqId)
                }

// .cn.tursom.im.protobuf.MsgContent content = 3;
                inline bool SendMsgRequest::_internal_has_content() const {
                    return this != internal_default_instance() && content_ != nullptr;
                }

                inline bool SendMsgRequest::has_content() const {
                    return _internal_has_content();
                }

                inline void SendMsgRequest::clear_content() {
                    if (GetArenaForAllocation() == nullptr && content_ != nullptr) {
                        delete content_;
                    }
                    content_ = nullptr;
                }

                inline const ::cn::tursom::im::protobuf::MsgContent &SendMsgRequest::_internal_content() const {
                    const ::cn::tursom::im::protobuf::MsgContent *p = content_;
                    return p != nullptr ? *p : reinterpret_cast<const ::cn::tursom::im::protobuf::MsgContent &>(
                            ::cn::tursom::im::protobuf::_MsgContent_default_instance_);
                }

                inline const ::cn::tursom::im::protobuf::MsgContent &SendMsgRequest::content() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.SendMsgRequest.content)
                    return _internal_content();
                }

                inline void SendMsgRequest::unsafe_arena_set_allocated_content(
                        ::cn::tursom::im::protobuf::MsgContent *content) {
                    if (GetArenaForAllocation() == nullptr) {
                        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(content_);
                    }
                    content_ = content;
                    if (content) {

                    } else {

                    }
                    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.tursom.im.protobuf.SendMsgRequest.content)
                }

                inline ::cn::tursom::im::protobuf::MsgContent *SendMsgRequest::release_content() {

                    ::cn::tursom::im::protobuf::MsgContent *temp = content_;
                    content_ = nullptr;
                    if (GetArenaForAllocation() != nullptr) {
                        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
                    }
                    return temp;
                }

                inline ::cn::tursom::im::protobuf::MsgContent *SendMsgRequest::unsafe_arena_release_content() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.SendMsgRequest.content)

                    ::cn::tursom::im::protobuf::MsgContent *temp = content_;
                    content_ = nullptr;
                    return temp;
                }

                inline ::cn::tursom::im::protobuf::MsgContent *SendMsgRequest::_internal_mutable_content() {

                    if (content_ == nullptr) {
                        auto *p = CreateMaybeMessage<::cn::tursom::im::protobuf::MsgContent>(GetArenaForAllocation());
                        content_ = p;
                    }
                    return content_;
                }

                inline ::cn::tursom::im::protobuf::MsgContent *SendMsgRequest::mutable_content() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.SendMsgRequest.content)
                    return _internal_mutable_content();
                }

                inline void SendMsgRequest::set_allocated_content(::cn::tursom::im::protobuf::MsgContent *content) {
                    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaForAllocation();
                    if (message_arena == nullptr) {
                        delete content_;
                    }
                    if (content) {
                        ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
                                ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::cn::tursom::im::protobuf::MsgContent>::GetOwningArena(
                                        content);
                        if (message_arena != submessage_arena) {
                            content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                                    message_arena, content, submessage_arena);
                        }

                    } else {

                    }
                    content_ = content;
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.SendMsgRequest.content)
                }

// -------------------------------------------------------------------

// SendMsgResponse

// string receiver = 1;
                inline void SendMsgResponse::clear_receiver() {
                    receiver_.ClearToEmpty();
                }

                inline const std::string &SendMsgResponse::receiver() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.SendMsgResponse.receiver)
                    return _internal_receiver();
                }

                template<typename ArgT0, typename... ArgT>
                inline PROTOBUF_ALWAYS_INLINE
                void SendMsgResponse::set_receiver(ArgT0 &&arg0, ArgT... args) {

                    receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                  static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.SendMsgResponse.receiver)
                }

                inline std::string *SendMsgResponse::mutable_receiver() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.SendMsgResponse.receiver)
                    return _internal_mutable_receiver();
                }

                inline const std::string &SendMsgResponse::_internal_receiver() const {
                    return receiver_.Get();
                }

                inline void SendMsgResponse::_internal_set_receiver(const std::string &value) {

                    receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                                  GetArenaForAllocation());
                }

                inline std::string *SendMsgResponse::_internal_mutable_receiver() {

                    return receiver_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                             GetArenaForAllocation());
                }

                inline std::string *SendMsgResponse::release_receiver() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.SendMsgResponse.receiver)
                    return receiver_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                             GetArenaForAllocation());
                }

                inline void SendMsgResponse::set_allocated_receiver(std::string *receiver) {
                    if (receiver != nullptr) {

                    } else {

                    }
                    receiver_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver,
                                           GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.SendMsgResponse.receiver)
                }

// string reqId = 2;
                inline void SendMsgResponse::clear_reqid() {
                    reqid_.ClearToEmpty();
                }

                inline const std::string &SendMsgResponse::reqid() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.SendMsgResponse.reqId)
                    return _internal_reqid();
                }

                template<typename ArgT0, typename... ArgT>
                inline PROTOBUF_ALWAYS_INLINE
                void SendMsgResponse::set_reqid(ArgT0 &&arg0, ArgT... args) {

                    reqid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                               static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.SendMsgResponse.reqId)
                }

                inline std::string *SendMsgResponse::mutable_reqid() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.SendMsgResponse.reqId)
                    return _internal_mutable_reqid();
                }

                inline const std::string &SendMsgResponse::_internal_reqid() const {
                    return reqid_.Get();
                }

                inline void SendMsgResponse::_internal_set_reqid(const std::string &value) {

                    reqid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                               GetArenaForAllocation());
                }

                inline std::string *SendMsgResponse::_internal_mutable_reqid() {

                    return reqid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                          GetArenaForAllocation());
                }

                inline std::string *SendMsgResponse::release_reqid() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.SendMsgResponse.reqId)
                    return reqid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                          GetArenaForAllocation());
                }

                inline void SendMsgResponse::set_allocated_reqid(std::string *reqid) {
                    if (reqid != nullptr) {

                    } else {

                    }
                    reqid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reqid,
                                        GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.SendMsgResponse.reqId)
                }

// bool success = 3;
                inline void SendMsgResponse::clear_success() {
                    success_ = false;
                }

                inline bool SendMsgResponse::_internal_success() const {
                    return success_;
                }

                inline bool SendMsgResponse::success() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.SendMsgResponse.success)
                    return _internal_success();
                }

                inline void SendMsgResponse::_internal_set_success(bool value) {

                    success_ = value;
                }

                inline void SendMsgResponse::set_success(bool value) {
                    _internal_set_success(value);
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.SendMsgResponse.success)
                }

// string failMsg = 4;
                inline void SendMsgResponse::clear_failmsg() {
                    failmsg_.ClearToEmpty();
                }

                inline const std::string &SendMsgResponse::failmsg() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.SendMsgResponse.failMsg)
                    return _internal_failmsg();
                }

                template<typename ArgT0, typename... ArgT>
                inline PROTOBUF_ALWAYS_INLINE
                void SendMsgResponse::set_failmsg(ArgT0 &&arg0, ArgT... args) {

                    failmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                 static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.SendMsgResponse.failMsg)
                }

                inline std::string *SendMsgResponse::mutable_failmsg() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.SendMsgResponse.failMsg)
                    return _internal_mutable_failmsg();
                }

                inline const std::string &SendMsgResponse::_internal_failmsg() const {
                    return failmsg_.Get();
                }

                inline void SendMsgResponse::_internal_set_failmsg(const std::string &value) {

                    failmsg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                                 GetArenaForAllocation());
                }

                inline std::string *SendMsgResponse::_internal_mutable_failmsg() {

                    return failmsg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                            GetArenaForAllocation());
                }

                inline std::string *SendMsgResponse::release_failmsg() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.SendMsgResponse.failMsg)
                    return failmsg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                            GetArenaForAllocation());
                }

                inline void SendMsgResponse::set_allocated_failmsg(std::string *failmsg) {
                    if (failmsg != nullptr) {

                    } else {

                    }
                    failmsg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), failmsg,
                                          GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.SendMsgResponse.failMsg)
                }

// .cn.tursom.im.protobuf.FailType failType = 5;
                inline void SendMsgResponse::clear_failtype() {
                    failtype_ = 0;
                }

                inline ::cn::tursom::im::protobuf::FailType SendMsgResponse::_internal_failtype() const {
                    return static_cast< ::cn::tursom::im::protobuf::FailType >(failtype_);
                }

                inline ::cn::tursom::im::protobuf::FailType SendMsgResponse::failtype() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.SendMsgResponse.failType)
                    return _internal_failtype();
                }

                inline void SendMsgResponse::_internal_set_failtype(::cn::tursom::im::protobuf::FailType value) {

                    failtype_ = value;
                }

                inline void SendMsgResponse::set_failtype(::cn::tursom::im::protobuf::FailType value) {
                    _internal_set_failtype(value);
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.SendMsgResponse.failType)
                }

// -------------------------------------------------------------------

// ChatMsg

// string receiver = 1;
                inline void ChatMsg::clear_receiver() {
                    receiver_.ClearToEmpty();
                }

                inline const std::string &ChatMsg::receiver() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.ChatMsg.receiver)
                    return _internal_receiver();
                }

                template<typename ArgT0, typename... ArgT>
                inline PROTOBUF_ALWAYS_INLINE
                void ChatMsg::set_receiver(ArgT0 &&arg0, ArgT... args) {

                    receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                  static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.ChatMsg.receiver)
                }

                inline std::string *ChatMsg::mutable_receiver() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.ChatMsg.receiver)
                    return _internal_mutable_receiver();
                }

                inline const std::string &ChatMsg::_internal_receiver() const {
                    return receiver_.Get();
                }

                inline void ChatMsg::_internal_set_receiver(const std::string &value) {

                    receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                                  GetArenaForAllocation());
                }

                inline std::string *ChatMsg::_internal_mutable_receiver() {

                    return receiver_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                             GetArenaForAllocation());
                }

                inline std::string *ChatMsg::release_receiver() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.ChatMsg.receiver)
                    return receiver_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                             GetArenaForAllocation());
                }

                inline void ChatMsg::set_allocated_receiver(std::string *receiver) {
                    if (receiver != nullptr) {

                    } else {

                    }
                    receiver_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver,
                                           GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.ChatMsg.receiver)
                }

// string sender = 2;
                inline void ChatMsg::clear_sender() {
                    sender_.ClearToEmpty();
                }

                inline const std::string &ChatMsg::sender() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.ChatMsg.sender)
                    return _internal_sender();
                }

                template<typename ArgT0, typename... ArgT>
                inline PROTOBUF_ALWAYS_INLINE
                void ChatMsg::set_sender(ArgT0 &&arg0, ArgT... args) {

                    sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set:cn.tursom.im.protobuf.ChatMsg.sender)
                }

                inline std::string *ChatMsg::mutable_sender() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.ChatMsg.sender)
                    return _internal_mutable_sender();
                }

                inline const std::string &ChatMsg::_internal_sender() const {
                    return sender_.Get();
                }

                inline void ChatMsg::_internal_set_sender(const std::string &value) {

                    sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value,
                                GetArenaForAllocation());
                }

                inline std::string *ChatMsg::_internal_mutable_sender() {

                    return sender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{},
                                           GetArenaForAllocation());
                }

                inline std::string *ChatMsg::release_sender() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.ChatMsg.sender)
                    return sender_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
                                           GetArenaForAllocation());
                }

                inline void ChatMsg::set_allocated_sender(std::string *sender) {
                    if (sender != nullptr) {

                    } else {

                    }
                    sender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender,
                                         GetArenaForAllocation());
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.ChatMsg.sender)
                }

// .cn.tursom.im.protobuf.MsgContent content = 3;
                inline bool ChatMsg::_internal_has_content() const {
                    return this != internal_default_instance() && content_ != nullptr;
                }

                inline bool ChatMsg::has_content() const {
                    return _internal_has_content();
                }

                inline void ChatMsg::clear_content() {
                    if (GetArenaForAllocation() == nullptr && content_ != nullptr) {
                        delete content_;
                    }
                    content_ = nullptr;
                }

                inline const ::cn::tursom::im::protobuf::MsgContent &ChatMsg::_internal_content() const {
                    const ::cn::tursom::im::protobuf::MsgContent *p = content_;
                    return p != nullptr ? *p : reinterpret_cast<const ::cn::tursom::im::protobuf::MsgContent &>(
                            ::cn::tursom::im::protobuf::_MsgContent_default_instance_);
                }

                inline const ::cn::tursom::im::protobuf::MsgContent &ChatMsg::content() const {
                    // @@protoc_insertion_point(field_get:cn.tursom.im.protobuf.ChatMsg.content)
                    return _internal_content();
                }

                inline void ChatMsg::unsafe_arena_set_allocated_content(
                        ::cn::tursom::im::protobuf::MsgContent *content) {
                    if (GetArenaForAllocation() == nullptr) {
                        delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite *>(content_);
                    }
                    content_ = content;
                    if (content) {

                    } else {

                    }
                    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cn.tursom.im.protobuf.ChatMsg.content)
                }

                inline ::cn::tursom::im::protobuf::MsgContent *ChatMsg::release_content() {

                    ::cn::tursom::im::protobuf::MsgContent *temp = content_;
                    content_ = nullptr;
                    if (GetArenaForAllocation() != nullptr) {
                        temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
                    }
                    return temp;
                }

                inline ::cn::tursom::im::protobuf::MsgContent *ChatMsg::unsafe_arena_release_content() {
                    // @@protoc_insertion_point(field_release:cn.tursom.im.protobuf.ChatMsg.content)

                    ::cn::tursom::im::protobuf::MsgContent *temp = content_;
                    content_ = nullptr;
                    return temp;
                }

                inline ::cn::tursom::im::protobuf::MsgContent *ChatMsg::_internal_mutable_content() {

                    if (content_ == nullptr) {
                        auto *p = CreateMaybeMessage<::cn::tursom::im::protobuf::MsgContent>(GetArenaForAllocation());
                        content_ = p;
                    }
                    return content_;
                }

                inline ::cn::tursom::im::protobuf::MsgContent *ChatMsg::mutable_content() {
                    // @@protoc_insertion_point(field_mutable:cn.tursom.im.protobuf.ChatMsg.content)
                    return _internal_mutable_content();
                }

                inline void ChatMsg::set_allocated_content(::cn::tursom::im::protobuf::MsgContent *content) {
                    ::PROTOBUF_NAMESPACE_ID::Arena *message_arena = GetArenaForAllocation();
                    if (message_arena == nullptr) {
                        delete content_;
                    }
                    if (content) {
                        ::PROTOBUF_NAMESPACE_ID::Arena *submessage_arena =
                                ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::cn::tursom::im::protobuf::MsgContent>::GetOwningArena(
                                        content);
                        if (message_arena != submessage_arena) {
                            content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
                                    message_arena, content, submessage_arena);
                        }

                    } else {

                    }
                    content_ = content;
                    // @@protoc_insertion_point(field_set_allocated:cn.tursom.im.protobuf.ChatMsg.content)
                }

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

            }  // namespace protobuf
        }  // namespace im
    }  // namespace tursom
}  // namespace cn

PROTOBUF_NAMESPACE_OPEN

        template<>
        struct is_proto_enum<::cn::tursom::im::protobuf::FailType> : ::std::true_type {
        };

        template<>
        inline const EnumDescriptor *GetEnumDescriptor<::cn::tursom::im::protobuf::FailType>() {
            return ::cn::tursom::im::protobuf::FailType_descriptor();
        }

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>

#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_TursomMsg_2eproto
