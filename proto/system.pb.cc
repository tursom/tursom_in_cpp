// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: system.proto

#include "system.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

constexpr ImToken::ImToken(
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
        : uid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string), sig_(uint64_t{0u}) {}

struct ImTokenDefaultTypeInternal {
    constexpr ImTokenDefaultTypeInternal()
            : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}

    ~ImTokenDefaultTypeInternal() {}

    union {
        ImToken _instance;
    };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ImTokenDefaultTypeInternal _ImToken_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_system_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const **file_level_enum_descriptors_system_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const **file_level_service_descriptors_system_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_system_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
        protodesc_cold) = {
        ~0u,  // no _has_bits_
        PROTOBUF_FIELD_OFFSET(::ImToken, _internal_metadata_),
        ~0u,  // no _extensions_
        ~0u,  // no _oneof_case_
        ~0u,  // no _weak_field_map_
        PROTOBUF_FIELD_OFFSET(::ImToken, sig_),
        PROTOBUF_FIELD_OFFSET(::ImToken, uid_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        {0, -1, sizeof(::ImToken)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const *const file_default_instances[] = {
        reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message *>(&::_ImToken_default_instance_),
};

const char descriptor_table_protodef_system_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
        "\n\014system.proto\"#\n\007ImToken\022\013\n\003sig\030\001 \001(\004\022\013"
        "\n\003uid\030\002 \001(\tB\030H\001Z\024./tursom_im_protobufb\006p"
        "roto3";
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_system_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_system_2eproto = {
        false, false, 85, descriptor_table_protodef_system_2eproto, "system.proto",
        &descriptor_table_system_2eproto_once, nullptr, 0, 1,
        schemas, file_default_instances, TableStruct_system_2eproto::offsets,
        file_level_metadata_system_2eproto, file_level_enum_descriptors_system_2eproto,
        file_level_service_descriptors_system_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable *
descriptor_table_system_2eproto_getter() {
    return &descriptor_table_system_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_system_2eproto(
        &descriptor_table_system_2eproto);

// ===================================================================

class ImToken::_Internal {
public:
};

ImToken::ImToken(::PROTOBUF_NAMESPACE_ID::Arena *arena)
        : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
    SharedCtor();
    RegisterArenaDtor(arena);
    // @@protoc_insertion_point(arena_constructor:ImToken)
}

ImToken::ImToken(const ImToken &from)
        : ::PROTOBUF_NAMESPACE_ID::Message() {
    _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
    uid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    if (!from._internal_uid().empty()) {
        uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_uid(),
                 GetArenaForAllocation());
    }
    sig_ = from.sig_;
    // @@protoc_insertion_point(copy_constructor:ImToken)
}

void ImToken::SharedCtor() {
    uid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    sig_ = uint64_t{0u};
}

ImToken::~ImToken() {
    // @@protoc_insertion_point(destructor:ImToken)
    SharedDtor();
    _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ImToken::SharedDtor() {
    GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
    uid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ImToken::ArenaDtor(void *object) {
    ImToken *_this = reinterpret_cast< ImToken * >(object);
    (void) _this;
}

void ImToken::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena *) {
}

void ImToken::SetCachedSize(int size) const {
    _cached_size_.Set(size);
}

void ImToken::Clear() {
// @@protoc_insertion_point(message_clear_start:ImToken)
    ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void) cached_has_bits;

    uid_.ClearToEmpty();
    sig_ = uint64_t{0u};
    _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char *ImToken::_InternalParse(const char *ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext *ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
    while (!ctx->Done(&ptr)) {
        ::PROTOBUF_NAMESPACE_ID::uint32 tag;
        ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
        switch (tag >> 3) {
            // uint64 sig = 1;
            case 1:
                if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
                    sig_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
                    CHK_(ptr);
                } else goto handle_unusual;
                continue;
                // string uid = 2;
            case 2:
                if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
                    auto str = _internal_mutable_uid();
                    ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
                    CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "ImToken.uid"));
                    CHK_(ptr);
                } else goto handle_unusual;
                continue;
            default: {
                handle_unusual:
                if ((tag == 0) || ((tag & 7) == 4)) {
                    CHK_(ptr);
                    ctx->SetLastTag(tag);
                    goto success;
                }
                ptr = UnknownFieldParse(tag,
                                        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
                                        ptr, ctx);
                CHK_(ptr != nullptr);
                continue;
            }
        }  // switch
    }  // while
    success:
    return ptr;
    failure:
    ptr = nullptr;
    goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8 *ImToken::_InternalSerialize(
        ::PROTOBUF_NAMESPACE_ID::uint8 *target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream *stream) const {
    // @@protoc_insertion_point(serialize_to_array_start:ImToken)
    ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
    (void) cached_has_bits;

    // uint64 sig = 1;
    if (this->sig() != 0) {
        target = stream->EnsureSpace(target);
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_sig(),
                                                                                       target);
    }

    // string uid = 2;
    if (!this->uid().empty()) {
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
                this->_internal_uid().data(), static_cast<int>(this->_internal_uid().length()),
                ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
                "ImToken.uid");
        target = stream->WriteStringMaybeAliased(
                2, this->_internal_uid(), target);
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
                _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
                        ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
    }
    // @@protoc_insertion_point(serialize_to_array_end:ImToken)
    return target;
}

size_t ImToken::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ImToken)
    size_t total_size = 0;

    ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
    // Prevent compiler warnings about cached_has_bits being unused
    (void) cached_has_bits;

    // string uid = 2;
    if (!this->uid().empty()) {
        total_size += 1 +
                      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
                              this->_internal_uid());
    }

    // uint64 sig = 1;
    if (this->sig() != 0) {
        total_size += 1 +
                      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
                              this->_internal_sig());
    }

    if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
        return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
                _internal_metadata_, total_size, &_cached_size_);
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
    SetCachedSize(cached_size);
    return total_size;
}

void ImToken::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) {
// @@protoc_insertion_point(generalized_merge_from_start:ImToken)
    GOOGLE_DCHECK_NE(&from, this);
    const ImToken *source =
            ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ImToken>(
                    &from);
    if (source == nullptr) {
        // @@protoc_insertion_point(generalized_merge_from_cast_fail:ImToken)
        ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
    } else {
        // @@protoc_insertion_point(generalized_merge_from_cast_success:ImToken)
        MergeFrom(*source);
    }
}

void ImToken::MergeFrom(const ImToken &from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ImToken)
    GOOGLE_DCHECK_NE(&from, this);
    _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
    (void) cached_has_bits;

    if (!from.uid().empty()) {
        _internal_set_uid(from._internal_uid());
    }
    if (from.sig() != 0) {
        _internal_set_sig(from._internal_sig());
    }
}

void ImToken::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message &from) {
// @@protoc_insertion_point(generalized_copy_from_start:ImToken)
    if (&from == this) return;
    Clear();
    MergeFrom(from);
}

void ImToken::CopyFrom(const ImToken &from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ImToken)
    if (&from == this) return;
    Clear();
    MergeFrom(from);
}

bool ImToken::IsInitialized() const {
    return true;
}

void ImToken::InternalSwap(ImToken *other) {
    using std::swap;
    _internal_metadata_.InternalSwap(&other->_internal_metadata_);
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
            &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
            &uid_, GetArenaForAllocation(),
            &other->uid_, other->GetArenaForAllocation()
    );
    swap(sig_, other->sig_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ImToken::GetMetadata() const {
    return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
            &descriptor_table_system_2eproto_getter, &descriptor_table_system_2eproto_once,
            file_level_metadata_system_2eproto[0]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
        template<>
        PROTOBUF_NOINLINE ::ImToken *Arena::CreateMaybeMessage<::ImToken>(Arena *arena) {
            return Arena::CreateMessageInternal<::ImToken>(arena);
        }
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
